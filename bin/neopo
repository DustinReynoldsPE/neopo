#!/usr/bin/env python3

# neopo: A lightweight solution for local Particle development.
# Copyright (c) 2020 Nathan Robinson.

import json
import zipfile
import io
import tarfile
import platform
import stat
import os
import pathlib
import sys
import subprocess
import shutil
import urllib.request

if platform.system().lower() not in ['darwin', 'linux']:
    exit('OS is not supported! Use Linux or macOS.')

# Global Variables
DEPS = os.environ['HOME'] + '/.particle/toolchains'

# Find the Workbench extension URL from the Visual Studio Marketplace 
def getExtensionURL():
    print("Finding Workbench extension URL...")
    payload = '{"assetTypes":null,"filters":[{"criteria":[{"filterType":7,"value":"particle.particle-vscode-core"}],"direction":2,"pageSize":100,"pageNumber":1,"sortBy":0,"sortOrder":0,"pagingToken":null}],"flags":103}'

    request = urllib.request.Request('https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery', method='POST', headers={
        'content-type': 'application/json',
        'accept': 'application/json;api-version=6.0-preview.1;excludeUrls=true'
    }, data=payload.encode('utf-8'))

    with urllib.request.urlopen(request) as response:
        content = response.read()
    
    data = json.loads(content.decode('utf-8'))
    return data['results'][0]['extensions'][0]['versions'][0]['files'][-1]['source']

# Download the the Workbench extension from the URL
def getExtension(url):
    print("Downloading Workbench extension...")
    with urllib.request.urlopen(url) as response:
        content = response.read()
    return zipfile.ZipFile(io.BytesIO(content), 'r')

# Load a file from a ZIP
def getFile(file, path):
    content = file.read(path)
    return content

# Download a dependency specified by the JSON
def downloadDep(dep, updateManifest):
    if updateManifest:
        writeManifest(dep)
    
    name, version, url = (dep['name'], dep['version'], dep['url'])
    print("Downloading dependency " + name + " version " + version + "...")

    path = DEPS + '/' + name + '/' + version
    pathlib.Path(path).mkdir(parents=True, exist_ok=True)

    with urllib.request.urlopen(url) as response:
        content = response.read()

    fileName = path + '/temp.tar.gz' 
    with open(fileName, 'wb') as gzFile:
        gzFile.write(content)

    with tarfile.open(fileName, 'r:gz') as file:
        file.extractall(path)

    os.remove(fileName)

# Write JSON data to a file
def writeFile(content, path):
    with open(path, 'wb') as file:
        file.write(content)

# Write an executable dependency to a file
def writeExecutable(content, path):
    with open(path, 'wb') as file:
        file.write(content)
        st = os.stat(file.name)
        os.chmod(file.name, st.st_mode | stat.S_IEXEC)

# Download extension manifest and simple dependencies
def getDeps():
    osPlatform = platform.system().lower()
    osArch = 'amd64' if platform.machine() == 'x86_64' else 'arm'

    extension = getExtension(getExtensionURL())
    pathlib.Path(DEPS + '/vscode/').mkdir(parents=True, exist_ok=True)
    manifest = getFile(extension, 'extension/src/compiler/manifest.json')
    particle = getFile(extension, 'extension/src/cli/bin/' + osPlatform + '/' + osArch + '/particle')
    launch = getFile(extension, 'extension/src/cli/vscode/launch.json')
    settings = getFile(extension, 'extension/src/cli/vscode/settings.json')

    writeFile(launch, DEPS + '/vscode/launch.json')
    writeFile(settings, DEPS + '/vscode/settings.json')
    writeExecutable(particle, DEPS + '/particle')
    createManifest()

    data = json.loads(manifest.decode('utf-8'))
    return data

# Write the settings to a JSON file
def writeManifest(dep):
    with open(DEPS + '/manifest.json', 'r+') as file:
        try:
            manifest = json.load(file)
        except json.decoder.JSONDecodeError:
            manifest = {}

        manifest[dep['name']] = dep['version']
        file.seek(0)
        json.dump(manifest, file, indent=4)
        file.truncate()

# Create the settings file
def createManifest():
    if not os.path.isfile(DEPS + '/manifest.json'):
        with open(DEPS + '/manifest.json', 'w') as file:
            pass

# Load settings from the JSON file
def loadManifest(tupleOrDict):
    with open(DEPS + '/manifest.json', 'r') as file:
        data = json.load(file)
        if tupleOrDict:
            return (data['gcc-arm'], data['buildscripts'], data['buildtools'], data['deviceOS'])
        else:
            return {'gcc-arm': data['gcc-arm'], 'buildscripts': data['buildscripts'], 'buildtools': data['buildtools'], 'deviceOS': data['deviceOS'], 'openocd': data['openocd']}

def writeJSONcache(data, key):
    with open(DEPS + '/' + key + '.json', 'w') as file:
        keyData = data[key]
        json.dump(keyData, file, indent=4)

# Download list of dependencies and install them
def install():
    print("Installing neopo...")
    dependencies = ['compilers', 'tools', 'scripts', 'debuggers']
    caches = ['firmware', 'platforms', 'toolchains']

    data = getDeps()
    depJSON = []
    depJSON.append(data['firmware'][0])

    for dep in dependencies:
        depJSON.append(data[dep][platform.system().lower()]['x64'][0])

    for key in caches:
        writeJSONcache(data, key)

    for dep in depJSON:
        downloadDep(dep, True)

# Delete the neopo script from the system
def uninstall():
    execpath = sys.argv[0]
    answer = input('Are you sure you want to uninstall neopo at ' + execpath + '? Type YES to continue (anything else to abort): ')

    if answer != 'YES':
        print('Aborted.')
        return

    os.remove(execpath)
    print('Uninstalled neopo.')
    print('Note: The .particle directory might still exist (remove it with `rm -rf ~/.particle`)')

# Create a Particle project and copy in Workbench settings
def create(path, name):
    tempEnv = os.environ.copy()
    addToPath(tempEnv, None)

    returncode = subprocess.run(['particle', 'project', 'create', path, '--name', name], env=tempEnv).returncode
    if returncode:
        exit(returncode)

    pathlib.Path(path + '/' + name + '/.vscode/').mkdir(parents=True, exist_ok=True)
    shutil.copyfile(DEPS + '/vscode/launch.json', path + '/' + name + '/.vscode/launch.json')
    shutil.copyfile(DEPS + '/vscode/settings.json', path + '/' + name + '/.vscode/settings.json')
    
    platform = 'argon'
    version = loadManifest(True)[-1]
    configure(path + '/' + name, platform, version)

def getFirmwareData(version):
    with open(DEPS + '/firmware.json', 'r') as  firmwareFile:
        data = json.load(firmwareFile)
        for entry in data:
            if entry['version'] == version:
                return entry
        return False

def deviceToPlatformID(device):
    with open(DEPS + '/platforms.json', 'r') as platformFile:
        platforms = json.load(platformFile)    
        for platform in platforms:
            if platform['name'] == device:
                return platform['id']
        return False

def platformToDevice(platformID):
    with open(DEPS + '/platforms.json', 'r') as platformFile:
        platforms = json.load(platformFile)
        for platform in platforms:
            if platform['id'] == platformID:
                return platform['name']
        return False

def getSupportedPlatforms(version):
    with open(DEPS + '/toolchains.json', 'r') as toolchainsFile:
        toolchains = json.load(toolchainsFile)
        for toolchain in toolchains:
            if toolchain['firmware'] == 'deviceOS@' + version:
                return toolchain['platforms']
        return False

def validateToolchain(platformID, version):
    return platformID in getSupportedPlatforms(version)

def checkFirmwareVersion(platform, version):
    firmware = getFirmwareData(version)
    platformID = deviceToPlatformID(platform)
    
    if not platformID:
        print('Invalid platform ' + platform + '!')
        return False

    if not firmware:
        print('Invalid deviceOS version ' + version + '!')
        return False

    if not validateToolchain(platformID, version):
        print('Platform ' + platform + ' is not supported in deviceOS version ' + version + '!')
        return False
    
    path = DEPS + '/deviceOS/' + version
    if os.path.isdir(path):
        return True
        
    downloadDep(firmware, False)
    return True

# Modify Workbench settings in a project (platform, firmwareVersion)
def configure(projectPath, platform, firmwareVersion):
    if not checkFirmwareVersion(platform, firmwareVersion):
        exit(1)

    writeSettings(projectPath, platform, firmwareVersion)
    print("Configured project " + projectPath + ':')
    print("\tparticle.targetPlatform: " + platform)
    print("\tparticle.firmwareVersion: " + firmwareVersion)

# Load Workbench settings from a project
def getSettings(projectPath):
    with open(projectPath + '/.vscode/settings.json', 'r+') as settings:
        data = json.loads(settings.read())
        return (data['particle.targetPlatform'], data['particle.firmwareVersion'])

def writeSettings(projectPath, platform, version):
    with open(projectPath + '/.vscode/settings.json', 'r+') as settings:
        data = json.loads(settings.read())
        data['particle.targetPlatform'] = platform
        data['particle.firmwareVersion'] = version
        settings.seek(0)
        json.dump(data, settings, indent=4)
        settings.truncate()

# Print help information directly from Makefile
def build_help():
    build(None, None, True)

def getFirmwarePath(version):
        deviceOSPath = DEPS + '/deviceOS/' + version
        legacy = '/firmware-' + version
        if os.path.isdir(deviceOSPath + legacy):
            deviceOSPath += legacy
        return deviceOSPath

def addToPath(tempEnv, args):
    tempEnv['PATH'] += ':' + DEPS
    for arg in args:
        tempEnv['PATH'] += arg

# Use the Makefile to build the specified target
def build(projectPath, command, helpFlag):
    compilerVersion, scriptVersion, toolsVersion, firmwareVersion = loadManifest(True)
    tempEnv = os.environ.copy()
    addToPath(tempEnv, ('/gcc-arm/', compilerVersion, '/bin'))
    addToPath(tempEnv, ('/buildtools/', toolsVersion))

    if helpFlag:
        process = ['make', '-sf', DEPS + '/buildscripts/' + scriptVersion + '/Makefile',
        'DEVICE_OS_PATH=' + DEPS + '/deviceOS/' + firmwareVersion, 'help']
    else:
        platform, firmwareVersion = getSettings(projectPath)
        deviceOSPath = getFirmwarePath(firmwareVersion)

        process = ['make', '-sf', DEPS + '/buildscripts/' + scriptVersion + '/Makefile',
               'PARTICLE_CLI_PATH=' + DEPS + '/particle', 'DEVICE_OS_PATH=' + deviceOSPath,
               'PLATFORM=' + platform, 'APPDIR=' + projectPath, command]

    returncode = subprocess.run(process, env=tempEnv).returncode
    if returncode:
        exit(returncode)

# Print help information about the program
def print_help():
    print("""Usage: neopo [OPTIONS] PROJECT

Options:
    General Options:
        help
        install
        uninstall
        versions
        create <project>

    Build Options:
        compile, build <project>
        flash <project>
        flash-all <project>
        clean <project>

    Special Options:
        run <target> <project>
        configure <platform> <version> <project>
        """)

# Parse the project path from the specified index and run a Makefile target
def buildCommand(command, index):
    try:
        project = os.environ['PWD'] + '/' + sys.argv[index]
    except IndexError:
        project = os.environ['PWD']
    try:
        build(project, command, False)
    except FileNotFoundError:
        print("Invalid project!")

# Print available versions and platforms
def versions():
    with open(DEPS + '/firmware.json', 'r') as firmwareFile:
        data = json.load(firmwareFile)
        print('Available deviceOS versions:')
        print()
        data.reverse()
        for entry in data:
            version = entry['version']
            platforms = getSupportedPlatforms(version)
            devices = []
            for platform in platforms:
                devices.append(platformToDevice(platform))
            
            devicesStr = devices[0]
            for device in devices[1:]:
                devicesStr += ', ' + device

            if len(version) < 8:
                version += '\t'
            print('  ' + version + '\t' +  '[ ' + devicesStr + ' ]')

        print()
        print('To configure a project use:') 
        print('\tneopo configure <platform> <version> <project>')

def configure_command():
    try:
            platform = sys.argv[2]
            version = sys.argv[3]
    except IndexError:
            print("You must supply platform and deviceOS version!")
            return
    try:
        projectPath = sys.argv[4]
    except IndexError:
        projectPath = os.environ['PWD']
        
    configure(projectPath, platform, version)

def run_command():
    try:
        command = sys.argv[2]
    except IndexError:
        build_help()
        print("You must supply a Makefile target!")
        return

    buildCommand(command, 3)

def create_command():
    try:
        projectPath = sys.argv[2]
    except IndexError:
        print("You must supply a path for the project!")
        return

    projectPath = os.path.abspath(projectPath)
    create(os.path.dirname(projectPath), os.path.basename(projectPath))

def flash_command():
    buildCommand('flash-user', 2)

def compile_command():
    buildCommand('compile-user', 2)

def flash_all_command():
    buildCommand('flash-all', 2)

def clean_command():
    buildCommand('clean-user', 2)

def downloadFirmware(version):
    firmware = getFirmwareData(version)
    if firmware:
        downloadDep(firmware, False)
    else:
        print("Could not download deviceOS version " + version + "!")
    
def update():
    print('Updating dependencies...')
    dependencies = ['compilers', 'tools', 'scripts', 'debuggers']
    caches = ['firmware', 'platforms', 'toolchains']

    manifest = loadManifest(False)
    data = getDeps()
    depJSON = []
    depJSON.append(data['firmware'][0])

    for dep in dependencies:
        depJSON.append(data[dep][platform.system().lower()]['x64'][0])

    for key in caches:
        writeJSONcache(data, key)

    for dep in depJSON:
        new = int(dep['version'].split('-')[0].replace('.', ''))
        old = int(manifest[dep['name']].split('-')[0].replace('.', ''))
        if new > old:
            downloadDep(dep, True)

    print('Dependencies are up to date!')

def get_command():
    try:
        version = sys.argv[2]
        downloadFirmware(version)
    except IndexError:
        print("You must specify a deviceOS version!")

# Evaluate command-line arguments and call necessary functions
def main():
    commands = {'help': print_help, 'install': install, 'uninstall': uninstall, 'versions': versions, 'create': create_command,
    'compile': compile_command, 'build': compile_command, 'flash': flash_command, 'flash-all': flash_all_command, 'clean': clean_command,
    'run': run_command, 'configure': configure_command, 'config': configure_command, 'update': update, 'get': get_command}

    if len(sys.argv) == 1:
        print_help()
        return
    
    if sys.argv[1] in commands:
        commands[sys.argv[1]]()
    else:
        print("Invalid command!")
        print_help()

if __name__ == "__main__":
    main()
