#!/usr/bin/env python3

# neopo: A lightweight solution for local Particle development.
# Copyright (c) 2020 Nathan Robinson.

import io
import os
import sys
import json
import stat
import shutil
import zipfile
import tarfile
import pathlib
import platform
import traceback
import subprocess
import urllib.request

# Custom errors
class UserError(RuntimeError):
    pass
class DependencyError(RuntimeError):
    pass
class ProcessError(RuntimeError):
    pass
class ProjectError(RuntimeError):
    pass

# Global Variables
PARTICLE_DEPS = os.path.join(os.path.expanduser("~"), ".particle", "toolchains")
NEOPO_DEPS = os.path.join(os.path.expanduser("~"), ".neopo")
CACHE_DIR = os.path.join(NEOPO_DEPS, "cache")
SCRIPTS_DIR = os.path.join(NEOPO_DEPS, "scripts")

raspberry_pi_gcc_arm = "https://github.com/nrobinson2000/neopo/releases/download/0.0.1/gcc-arm-v5.3.1-raspberry-pi.tar.gz"
running_on_windows = platform.system() == "Windows"
particle_cli = os.path.join(NEOPO_DEPS, "particle.exe") if running_on_windows else os.path.join(NEOPO_DEPS, "particle")

jsonFiles = {
    "firmware": os.path.join(CACHE_DIR, "firmware.json"),
    "toolchains": os.path.join(CACHE_DIR, "toolchains.json"),
    "platforms": os.path.join(CACHE_DIR, "platforms.json"),
    "manifest": os.path.join(CACHE_DIR, "manifest.json")
}

vscodeFiles = {
    "dir": os.path.join(NEOPO_DEPS, "vscode"),
    "launch": os.path.join(NEOPO_DEPS, "vscode", "launch.json"),
    "settings": os.path.join(NEOPO_DEPS, "vscode", "settings.json")
}

extensionFiles = {
    "bin": "extension/src/cli/bin",
    "manifest": "extension/src/compiler/manifest.json",
    "launch": "extension/src/cli/vscode/launch.json",
    "settings": "extension/src/cli/vscode/settings.json"
}

projectFiles = {
    "launch": os.path.join(".vscode", "launch.json"),
    "settings": os.path.join(".vscode", "settings.json"),
    "properties": "project.properties"
}

# Find the Workbench extension URL from the Visual Studio Marketplace
def getExtensionURL():
    print("Finding Workbench extension URL...")
    payload = '{"assetTypes":null,"filters":[{"criteria":[{"filterType":7,"value":"particle.particle-vscode-core"}],"direction":2,"pageSize":100,"pageNumber":1,"sortBy":0,"sortOrder":0,"pagingToken":null}],"flags":103}'

    request = urllib.request.Request(
        "https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery",
        method="POST",
        headers={
            "content-type": "application/json",
            "accept": "application/json;api-version=6.0-preview.1;excludeUrls=true",
        }, data=payload.encode("utf-8"))

    try:
        with urllib.request.urlopen(request) as response:
            content = response.read()
    except urllib.error.URLError:
        raise DependencyError("Failed to get extension URL!")

    data = json.loads(content.decode("utf-8"))
    return data["results"][0]["extensions"][0]["versions"][0]["files"][-1]["source"]

# Download the the Workbench extension from the URL
def getExtension(url):
    print("Downloading Workbench extension...")
    try:
        with urllib.request.urlopen(url) as response:
            content = response.read()
    except urllib.error.URLError:
        raise DependencyError("Failed to download extension!")
    return zipfile.ZipFile(io.BytesIO(content), "r")

# Load a file from a ZIP
def getFile(file, path):
    return file.read(path)

# Download the specified dependency
def downloadDep(dep, updateManifest):
    if updateManifest:
        writeManifest(dep)

    name, version, url = dep["name"], dep["version"], dep["url"]
    print("Downloading dependency", name, "version", version + "...")

    try:
        with urllib.request.urlopen(url) as response:
            content = response.read()
    except urllib.error.URLError:
        raise DependencyError("Failed to download dependency!")

    path = os.path.join(PARTICLE_DEPS, name, version)
    pathlib.Path(path).mkdir(parents=True, exist_ok=True)

    fileName = os.path.join(path, name + "-v" + version + ".tar.gz")
    with open(fileName, "wb") as gzFile:
        gzFile.write(content)

    with tarfile.open(fileName, "r:gz") as file:
        file.extractall(path)

    os.remove(fileName)

# Write JSON data to a file
def writeFile(content, path):
    with open(path, "wb") as file:
        file.write(content)

# Write an executable dependency to a file
def writeExecutable(content, path):
    with open(path, "wb") as file:
        file.write(content)
        st = os.stat(file.name)
        os.chmod(file.name, st.st_mode | stat.S_IEXEC)

# Download extension manifest and simple dependencies
def getDeps():
    osPlatform = platform.system().lower()
    osArch = platform.machine().lower() if running_on_windows else "amd64" if platform.machine() == "x86_64" else "arm"

    pathlib.Path(CACHE_DIR).mkdir(parents=True, exist_ok=True)
    pathlib.Path(SCRIPTS_DIR).mkdir(parents=True, exist_ok=True)

    extension = getExtension(getExtensionURL())
    pathlib.Path(vscodeFiles["dir"]).mkdir(parents=True, exist_ok=True)
    manifest = getFile(extension, extensionFiles["manifest"])

    try:
        particle_bin = os.path.basename(particle_cli)
        particle = getFile(extension, "/".join([extensionFiles["bin"], osPlatform, osArch, particle_bin]))
        writeExecutable(particle, particle_cli)
    except KeyError:
        raise DependencyError("Failed to download particle executable from extension!")

    launch = getFile(extension, extensionFiles["launch"])
    settings = getFile(extension, extensionFiles["settings"])
    writeFile(launch, vscodeFiles["launch"])
    writeFile(settings, vscodeFiles["settings"])

    createManifest()
    return json.loads(manifest.decode("utf-8"))

# Update the manifest JSON file
def writeManifest(dep):
    with open(jsonFiles["manifest"], "r+") as file:
        try:
            manifest = json.load(file)
        except json.decoder.JSONDecodeError:
            manifest = {}

        manifest[dep["name"]] = dep["version"]
        file.seek(0)
        json.dump(manifest, file, indent=4)
        file.truncate()

# Create the manifest file
def createManifest():
    if not os.path.isfile(jsonFiles["manifest"]):
        with open(jsonFiles["manifest"], "w") as file:
            pass

# Load settings from the JSON file
def loadManifest(tupleOrDict):
    with open(jsonFiles["manifest"], "r") as file:
        try:
            data = json.load(file)
        except json.decoder.JSONDecodeError:
            return None
        if tupleOrDict:
            return (
                data["gcc-arm"],
                data["buildscripts"],
                data["buildtools"],
                data["deviceOS"]
            )
        else:
            return {
                "gcc-arm": data["gcc-arm"],
                "buildscripts": data["buildscripts"],
                "buildtools": data["buildtools"],
                "deviceOS": data["deviceOS"],
                "openocd": data["openocd"]
            }

# Write an object to JSON file
def writeJSONcache(data, key):
    with open(jsonFiles[key], "w") as file:
        keyData = data[key]
        json.dump(keyData, file, indent=4)

# Attempt to download deviceOS version not specified in manifest (experimental)
def downloadUnlisted(version):
    firmware = {
        "name": "deviceOS",
        "version": version,
        "url": "https://binaries.particle.io/device-os/v" + version + ".tar.gz"
    }

    print("Trying binaries.particle.io/device-os...")

    try:
        downloadDep(firmware, False)
        return
    except urllib.error.URLError:
        print("DeviceOS version", version, "not found!\n")

    # Try to download from github
    firmware = {
        "name": "deviceOS",
        "version": version,
        "url": "https://github.com/particle-iot/device-os/archive/v" + version + ".tar.gz"
    }

    print("Trying github.com/particle-iot/device-os...")

    try:
        downloadDep(firmware, False)
        return
    except urllib.error.URLError:
        raise DependencyError("DeviceOS version " + version + " not found!")

# Wrapper for [download-unlisted]
def downloadUnlisted_command(args):
    try:
        downloadUnlisted(args[2])
    except IndexError:
        raise UserError("You must specify a deviceOS version!")

# Download a specific deviceOS version
def downloadFirmware(version):
    firmware = getFirmwareData(version)
    if firmware:
        downloadDep(firmware, False)
    else:
        print("Could not download deviceOS version", version + "!")

# Install or update neopo dependencies (not the neopo script)
def installOrUpdate(install, force):    
    forceInstall = force == "-f"
    if install:
        print("Installing neopo...")
    else:
        print("Updating dependencies...")

    dependencies = ["compilers", "tools", "scripts", "debuggers"]
    caches = ["firmware", "platforms", "toolchains"]

    data = getDeps()
    depJSON = [data["firmware"][0]]
    system = platform.system().lower()

    for dep in dependencies:
        depJSON.append(data[dep][system]["x64"][0])

    # Support for Raspberry Pi
    if platform.machine() == "armv7l":
        for dep in depJSON:
            if dep["name"] == "gcc-arm":
                dep["url"] = raspberry_pi_gcc_arm
                break

    for key in caches:
        writeJSONcache(data, key)

    manifest = loadManifest(False)

    if install:
        skippedDeps = []
        for dep in depJSON:
            new = dep["version"]
            old = manifest[dep["name"]] if dep["name"] in manifest else None
            if new != old or forceInstall:
                downloadDep(dep, True)
            else:
                skippedDeps.append(dep)
        
        print("Skipped previously installed dependencies:")
        print(*[dep["name"]+"@"+dep["version"] for dep in skippedDeps], sep=", ")
        print()
                    
        print("Finished installation. To create a project use:")
        print("\tneopo create <project>")
    else:
        for dep in depJSON:
            new = int(dep["version"].split("-")[0].replace(".", ""))
            old = int(manifest[dep["name"]].split("-")[0].replace(".", ""))
            if new > old:
                downloadDep(dep, True)
        print("Dependencies are up to date!")

# Delete the neopo script from the system
def uninstall(args):
    execpath = args[0]
    print("Are you sure you want to uninstall neopo at", execpath + "?")

    answer = input("(Y/N): ")
    if answer.lower() != "y":
        raise UserError("Aborted.")

    try:
        os.remove(execpath)
        print("Uninstalled neopo.")
        print("Note: The .particle directory may still exist (remove it with `rm -rf ~/.particle`)")
    except PermissionError:
        raise ProcessError("Could not delete " + execpath + "\n" + "Try running with sudo.")

# Create a Particle project and copy in Workbench settings
def create(path, name):
    tempEnv = os.environ.copy()
    addToPath(tempEnv, NEOPO_DEPS)

    projectPath = os.path.join(path, name)

    returncode = subprocess.run(
        ["particle", "project", "create", path, "--name", name],
        env=tempEnv,
        shell=running_on_windows).returncode
    if returncode:
        raise ProcessError("Failed with code " + str(returncode))

    # Initialize project as git repo and add .travis.yml
    if shutil.which("git"):
        subprocess.run(["git", "init", projectPath])

        travis = """# Build a neopo project with travis
os: linux
language: bash
sudo: required
install:
  - export PATH="$PATH:$PWD"
  - sudo apt update
  - sudo apt install libarchive-zip-perl libc6-i386
  - curl -LO https://raw.githubusercontent.com/nrobinson2000/neopo/master/bin/neopo
  - chmod +x neopo
  - neopo install
script:
  - neopo build
cache:
  directories:
    - $HOME/.particle
    - $HOME/.neopo
"""
        with open(os.path.join(projectPath, ".travis.yml"), "w") as ymlFile:
            ymlFile.write(travis)


    #TODO:
    # Minify README.md

    #TODO: Add .gitignore


    # Change name/src/name.ino to name/src/name.cpp
    # Add #include "Particle.h"

    include = '#include "Particle.h"\n'
    src = os.path.join(projectPath, "src", name + ".ino")
    dst = os.path.join(projectPath, "src", name + ".cpp")
    shutil.move(src, dst)

    with open(dst, "r") as original:
        data = original.read()
    with open(dst, "w") as modified:
        modified.write(include + data)

    #TODO: Default device in manifest.json
    device = "argon"
    version = loadManifest(False)["deviceOS"]
    configure(projectPath, device, version)

# Get a deviceOS dependency from a version
def getFirmwareData(version):
    with open(jsonFiles["firmware"], "r") as firmwareFile:
        for entry in json.load(firmwareFile):
            if entry["version"] == version:
                return entry
        return False

# Convert between platform IDs and device names
def platformConvert(data, key1, key2):
    with open(jsonFiles["platforms"], "r") as platformFile:
        for platform in json.load(platformFile):
            if platform[key1] == data:
                return platform[key2]
        return False

# List the supported platform IDs for a given version
def getSupportedPlatforms(version):
    with open(jsonFiles["toolchains"], "r") as toolchainsFile:
        for toolchain in json.load(toolchainsFile):
            if toolchain["firmware"] == "deviceOS@" + version:
                return toolchain["platforms"]
        return False

# Verify platform and deviceOS version and download deviceOS dependency if required
def checkFirmwareVersion(platform, version):
    firmware = getFirmwareData(version)
    platformID = platformConvert(platform, "name", "id")

    if not platformID:
        print("Invalid platform", platform + "!")
        return False

    if not firmware:
        print("Invalid deviceOS version", version + "!")
        return False

    if not platformID in getSupportedPlatforms(version):
        print("Platform", platform, " is not supported in deviceOS version", version + "!")
        return False

    path = os.path.join(PARTICLE_DEPS, "deviceOS", version)
    if os.path.isdir(path):
        return True

    downloadDep(firmware, False)
    return True

# Modify Workbench settings in a project (platform, firmwareVersion)
def configure(projectPath, platform, firmwareVersion):
    if not checkFirmwareVersion(platform, firmwareVersion):
        raise ProjectError("Firmware related error!")

    if not os.path.isfile(os.path.join(projectPath, projectFiles["properties"])):
        raise ProjectError(projectPath + " is not a Particle project!")

    if not os.path.isfile(os.path.join(projectPath, projectFiles["settings"])):
        pathlib.Path(os.path.join(projectPath, ".vscode")).mkdir(parents=True, exist_ok=True)
        shutil.copyfile(vscodeFiles["launch"], os.path.join(projectPath, projectFiles["launch"]))
        shutil.copyfile(vscodeFiles["settings"], os.path.join(projectPath, projectFiles["settings"]))

    writeSettings(projectPath, platform, firmwareVersion)
    print("Configured project", projectPath + ":")
    print("\tparticle.targetPlatform:", platform)
    print("\tparticle.firmwareVersion:", firmwareVersion)

# Load Workbench settings from a project
def getSettings(projectPath):
    with open(os.path.join(projectPath, projectFiles["settings"]), "r+") as settings:
        data = json.loads(settings.read())
        return (data["particle.targetPlatform"], data["particle.firmwareVersion"])

# Update Workbench settings in a project
def writeSettings(projectPath, platform, version):
    with open(os.path.join(projectPath, projectFiles["settings"]), "r+") as settings:
        data = json.loads(settings.read())
        data["particle.targetPlatform"] = platform
        data["particle.firmwareVersion"] = version
        settings.seek(0)
        json.dump(data, settings, indent=4)
        settings.truncate()

# Print help information directly from Makefile
def build_help():
    build(None, None, True, 0)

# Create the path string for a given deviceOS version
def getFirmwarePath(version):
    deviceOSPath = os.path.join(PARTICLE_DEPS, "deviceOS", version)
    legacy = os.path.join(deviceOSPath, "firmware-" + version)
    github = os.path.join(deviceOSPath, "device-os-" + version)
    return legacy if os.path.isdir(legacy) else github if os.path.isdir(github) else deviceOSPath

# Add a path to an environment
def addToPath(environment, path):
        environment["PATH"] = path + os.pathsep + environment["PATH"]

# Use the Makefile to build the specified target
def build(projectPath, command, helpOnly, verbosity):
    compilerVersion, scriptVersion, toolsVersion, firmwareVersion = loadManifest(True)
    tempEnv = os.environ.copy()
    addToPath(tempEnv, os.path.join(PARTICLE_DEPS, "gcc-arm", compilerVersion, "bin"))

    particle = particle_cli

    if running_on_windows:
        addToPath(tempEnv, os.path.join(PARTICLE_DEPS, "buildtools", toolsVersion, "bin"))
        particle = particle.replace("C:\\", "/cygdrive/c/")
        particle = particle.replace("\\", "/")
        projectPath = projectPath.replace("\\", "\\\\")
    else:
        addToPath(tempEnv, os.path.join(PARTICLE_DEPS, "buildtools", toolsVersion))

    process = [
        "make", "-sf",
        os.path.join(PARTICLE_DEPS, "buildscripts", scriptVersion, "Makefile"),
        "PARTICLE_CLI_PATH=" + particle
    ]

    # Remove [s] flag from make to get verbose output
    process[1] = "-f" if verbosity == 1 else "-sf"

    if helpOnly:
        process.append("help")
    else:
        try:
            devicePlatform, firmwareVersion = getSettings(projectPath)
        except FileNotFoundError:
            if os.path.isfile(os.path.join(projectPath, projectFiles["properties"])):
                raise ProjectError("Project not configured!" + "\n" + "Use: neopo configure <platform> <version> <project>")
            else:
                raise ProjectError(projectPath + " is not a Particle project!")
            
        deviceOSPath = getFirmwarePath(firmwareVersion)
        process.append("APPDIR=" + projectPath)
        process.append("DEVICE_OS_PATH=" + deviceOSPath)
        process.append("PLATFORM=" + devicePlatform)
        process.append(command)

    returncode = subprocess.run(process, env=tempEnv,
                                shell=running_on_windows,
                                stdout= subprocess.PIPE if verbosity == -1 else None,
                                stderr= subprocess.PIPE if verbosity == -1 else None
                                ).returncode
    if returncode:
        raise ProcessError("Failed with code " + str(returncode))

# Parse the project path from the specified index and run a Makefile target
def buildCommand(command, index, args):
    verboseIndex = index
    project = None
    verbosityDict = {"-v": 1, "-q": -1}

    try:
        if not args[index].startswith("-"):
            project = os.path.abspath(args[index])
            verboseIndex += 1
        else:
            project = os.getcwd()
    except IndexError:
        project = os.getcwd()
        verboseIndex = index
    try:
        verbosityStr = args[verboseIndex]
        verbosity = verbosityDict[verbosityStr]
    except IndexError:
        verbosity = 0
    except KeyError:
        raise UserError("Invalid verbosity!")

    build(project, command, False, verbosity)

# Print available versions compressed (for completion)
def versions_compressed(args):
    with open(jsonFiles["firmware"], "r") as firmwareFile:
        print(*[entry["version"] for entry in json.load(firmwareFile)])

# Print available platforms (for completion)
def platforms_command(args):
    with open(jsonFiles["platforms"], "r") as platformFile:
        print(*[entry["name"] for entry in json.load(platformFile)])

# Find all valid projects in PWD (for completion)
def findValidProjects(args):
    (_, dirs, _) = next(os.walk(os.getcwd()))
    print(*[dir for dir in dirs if os.access(os.path.join(dir, projectFiles["properties"]), os.R_OK)])

# Find all makefile targets (for completion)
def getMakefileTargets(args):
    with open(jsonFiles["manifest"], "r") as manifest:
        with open(os.path.join(PARTICLE_DEPS, "buildscripts", json.load(manifest)["buildscripts"], "Makefile")) as makefile:
            sep = ".PHONY: "
            print(*[line.partition(sep)[2].strip("\n") for line in makefile.readlines() if line.startswith(sep)])

# Print available versions and platforms
def versions(args):
    print("Available deviceOS versions:\n")
    with open(jsonFiles["firmware"], "r") as firmwareFile:
        for entry in reversed(json.load(firmwareFile)):
            version = entry["version"]
            devicesStr = ", ".join([platformConvert(platform, "id", "name") for platform in getSupportedPlatforms(version)])
            print("  ", version + "\t", "[", devicesStr, "]")

        print("\nTo configure a project use:")
        print("\tneopo configure <platform> <version> <project>")

# Wrapper for [config/configure]
def configure_command(args):
    try:
        projectPath = args[4] if len(args) >= 5 else os.getcwd()
        configure(projectPath, args[2], args[3])
    except IndexError:
        raise UserError("You must supply platform and deviceOS version!")

# Wrapper for [run]
def run_command(args):
    try:
        buildCommand(args[2], 3, args)
    except IndexError:
        build_help()
        raise UserError("You must supply a Makefile target!")

# Wrapper for [create]
def create_command(args):
    try:
        projectPath = os.path.abspath(args[2])
        create(os.path.dirname(projectPath), os.path.basename(projectPath))
    except IndexError:
        raise UserError("You must supply a path for the project!")

# Wrapper for [get]
def get_command(args):
    try:
        downloadFirmware(args[2])
    except IndexError:
        raise UserError("You must specify a deviceOS version!")

# More wrappers
def flash_command(args):
    buildCommand("flash-user", 2, args)
def compile_command(args):
    buildCommand("compile-user", 2, args)
def flash_all_command(args):
    buildCommand("flash-all", 2, args)
def clean_command(args):
    buildCommand("clean-user", 2, args)

def install_command(args):
    try:
        force = args[2]
    except IndexError:
        force = None
    installOrUpdate(True, force)

def update_command(args):
    try:
        force = args[2]
    except IndexError:
        force = None
    installOrUpdate(False, force)

# List all scripts installed (for completion)
def listScripts(args):
    (_, _, files) = next(os.walk(SCRIPTS_DIR))
    print(*files)

# Load a script into the scripts directory
def load(args):
    try:
        scriptPath = args[2]
        shutil.copyfile(scriptPath, os.path.join(SCRIPTS_DIR, os.path.basename(scriptPath)))
        print("Copied", scriptPath, "into", SCRIPTS_DIR)
    except IndexError:
        raise UserError("You must specify a script file!")

# Wrapper for [script]
def script(args):
    try:
        name = args[2]
    except IndexError:
        raise UserError("You must supply a script name!")

    scriptPath = os.path.join(SCRIPTS_DIR, name)

    try:
        with open(scriptPath, "r") as script:
            for line in script.readlines():
                if line.startswith("#"):
                    continue

                process = [args[0], *line.split()]

                if len(process) > 1:
                    print(process)
                    try:
                        commands[process[1]](process)
                    except KeyError:
                        raise UserError("Invalid command!")

    except FileNotFoundError:
        raise ProcessError("Could find script!")

# Print all iterable options (for completion)
def iterate_options(args):
    print(*iterable_commands)

# Available options for iterate
iterable_commands = {
    "compile": compile_command,
    "build": compile_command,
    "flash": flash_command,
    "flash-all": flash_all_command,
    "clean": clean_command,
    "run": run_command,
    "script": script
}

# Iterate through all connected devices and run a command
def iterate_command(args):
    tempEnv = os.environ.copy()
    addToPath(tempEnv, NEOPO_DEPS)

    process = ["particle", "serial", "list"]
    particle = subprocess.run(process, stdout=subprocess.PIPE,
                                        env=tempEnv,
                                        shell=running_on_windows)

    devices = [line.decode("utf-8").split()[-1] for line in particle.stdout.splitlines()[1:]]

    if not devices:
        raise ProcessError("No devices found!")

    del args[1]

    try:
        if args[1] == "iterate":
            raise UserError("Do not use `iterate` recursively!")
        elif not args[1] in iterable_commands.keys():
            raise UserError("Invalid command!")
    except IndexError:
        raise UserError("You must supply a command to iterate with!")

    for device in devices:
        print("DeviceID:", device)
        process = ["particle", "usb", "dfu", device]
        subprocess.run(process, stderr=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                env=tempEnv,
                                shell=running_on_windows)

        iterable_commands[args[1]](args)
            
# Print help information about the program
def print_help(args):
    print("""Usage: neopo [OPTIONS] [PROJECT] [-v/q]

Options:
    General Options:
        help                    # Show this help information
        install                 # Install neopo dependencies
        uninstall               # Uninstall neopo script
        versions                # List available versions and platforms
        create <project>        # Create a Workbench/neopo project

    Build Options:
        compile/build [project] [-v/q]  # Build a project: `compile-user`
        flash [project] [-v/q]          # Flash a project: `flash-user`
        flash-all [project] [-v/q]      # Flash a project: `flash-all`
        clean [project] [-v/q]          # Clean a project: `clean-user`

    Special Options:
        run <target> [project] [-v/q]             # Run a makefile target
        configure <platform> <version> [project]  # Configure a project
        iterate <command> [OPTIONS] [-v/q]        # Put devices into DFU mode
                                                  # and run commands on them
    Script Options:
        script <script name>    # Execute a script in ~/.neopo/scripts
        load <script name>      # Copy a script into ~/.neopo/scripts

    Dependency Options:
        update                  # Update neopo dependencies
        get <version>           # Download a specific deviceOS version
        """)

# Print all commands (for completion)
def options(args):
    print(*commands)

# Available options
commands = {
    "help": print_help,
    "install": install_command,
    "uninstall": uninstall,
    "versions": versions,
    "create": create_command,
    "compile": compile_command,
    "build": compile_command,
    "flash": flash_command,
    "flash-all": flash_all_command,
    "clean": clean_command,
    "run": run_command,
    "configure": configure_command,
    "update": update_command,
    "get": get_command,
    "list-versions": versions_compressed,
    "platforms": platforms_command,
    "projects": findValidProjects,
    "targets": getMakefileTargets,
    "options": options,
    "download-unlisted": downloadUnlisted_command,
    "script": script,
    "list-scripts": listScripts,
    "load": load,
    "iterate": iterate_command,
    "options-iterable": iterate_options
}

# Evaluate command-line arguments and call necessary functions
def main():
    if len(sys.argv) == 1:
        print_help(sys.argv)
    elif sys.argv[1] in commands:
        try:
            commands[sys.argv[1]](sys.argv)
        except RuntimeError as e:
            print(e)
            exit(1)
        except Exception as e:
            traceback.print_exc()
            print("An unexpected error occurred!")
            print("To report this error on GitHub, please open an issue:")
            print("https://github.com/nrobinson2000/neopo/issues")
            exit(2)
    else:
        print("Invalid command!")
        print_help(sys.argv)
        exit(3)

if __name__ == "__main__":
    main()
