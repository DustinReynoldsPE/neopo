#!/usr/bin/env python3

# neopo: A lightweight solution for local Particle development.
# Copyright (c) 2020 Nathan Robinson.

import json
import zipfile
import io
import gzip
import tarfile
import platform
import stat
import os
import pathlib
import sys
import subprocess
import shutil
import urllib.request

if platform.system().lower() not in ['darwin', 'linux']:
    exit('OS is not supported! Use Linux or macOS.')

# Global Variables
DEPS = os.environ['HOME'] + '/.particle/toolchains'

# Find the Workbench extension URL from the Visual Studio Marketplace 
def getExtensionURL():
    print("Finding Workbench extension URL...")

    payload = '{"assetTypes":null,"filters":[{"criteria":[{"filterType":7,"value":"particle.particle-vscode-core"}],"direction":2,"pageSize":100,"pageNumber":1,"sortBy":0,"sortOrder":0,"pagingToken":null}],"flags":103}'

    request = urllib.request.Request('https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery', method='POST', headers={
        'content-type': 'application/json',
        'accept': 'application/json;api-version=6.0-preview.1;excludeUrls=true'
    }, data=payload.encode('utf-8'))

    with urllib.request.urlopen(request) as response:
        content = response.read()
    
    data = json.loads(content.decode('utf-8'))
    latest = data['results'][0]['extensions'][0]['versions'][0]['files'][-1]['source']

    return latest

# Download the the Workbench extension from the URL
def getExtension(url):
    print("Downloading Workbench extension...")

    with urllib.request.urlopen(url) as response:
        content = response.read()

    return zipfile.ZipFile(io.BytesIO(content), 'r')

# Load a file from a ZIP
def getFile(file, path):
    content = file.read(path)
    return content

# Download a dependency specified by the JSON
def downloadDep(dep):
    writeManifest(dep)
    name = dep['name']
    version = dep['version']

    print("Downloading dependency " + name + " version " + version + "...")

    path = name + '/' + version
    path = DEPS + '/' + path
    url = dep['url']

    pathlib.Path(path).mkdir(parents=True, exist_ok=True)

    with urllib.request.urlopen(url) as response:
        content = response.read()

    fileName = path + '/temp.tar.gz' 
    gzFile = open(fileName, 'wb')
    gzFile.write(content)
    gzFile.close()
    response.close()

    with tarfile.open(fileName, 'r:gz') as file:
        file.extractall(path)

    os.remove(fileName)


# Write JSON data to a file
def writeFile(content, path):
    with open(path, 'w') as file:
        file.write(content)

# Write an executable dependency to a file
def writeExecutable(content, path):
    with open(path, 'wb') as file:
        file.write(content)
        st = os.stat(file.name)
        os.chmod(file.name, st.st_mode | stat.S_IEXEC)

# Download extension manifest and simple dependencies
def getDeps():
    osPlatform = platform.system().lower()
    osArch = 'amd64' if platform.machine() == 'x86_64' else 'arm'

    url = getExtensionURL()
    extension = getExtension(url)

    pathlib.Path(DEPS + '/vscode/').mkdir(parents=True, exist_ok=True)

    manifest = getFile(extension, 'extension/src/compiler/manifest.json')
    particle = getFile(extension, 'extension/src/cli/bin/' +
                       osPlatform + '/' + osArch + '/particle')

    launch = getFile(
        extension, 'extension/src/cli/vscode/launch.json').decode('utf-8')
    settings = getFile(
        extension, 'extension/src/cli/vscode/settings.json').decode('utf-8')

    writeFile(launch, DEPS + '/vscode/launch.json')
    writeFile(settings, DEPS + '/vscode/settings.json')

    writeExecutable(particle, DEPS + '/particle')

    data = json.loads(manifest.decode('utf-8'))
    return data

# Write the settings to a JSON file
def writeManifest(dep):
    with open(DEPS + '/manifest.json', 'r+') as file:
        try:
            manifest = json.loads(file.read())
        except json.decoder.JSONDecodeError:
            manifest = {}

        manifest[dep['name']] = dep['version']
        file.seek(0)
        json.dump(manifest, file, indent=4)
        file.truncate()

# Create the settings file
def createManifest():
    with open(DEPS + '/manifest.json', 'w') as file:
        pass

# Load settings from the JSON file
def loadManifest():
    with open(DEPS + '/manifest.json', 'r') as file:
        return json.loads(file.read())

# Download list of dependencies and install them
def install():
    print("Installing neopo...")
    osPlatform = platform.system().lower()
    data = getDeps()
    firmware = data['firmware'][0]
    compilers = data['compilers'][osPlatform]['x64'][0]
    tools = data['tools'][osPlatform]['x64'][0]
    scripts = data['scripts'][osPlatform]['x64'][0]
    debuggers = data['debuggers'][osPlatform]['x64'][0]

    firmwareList = data['firmware']
    firmwareFile = open(DEPS + '/firmware.json', 'w')
    json.dump(firmwareList, firmwareFile, indent=4)
    firmwareFile.close()

    platformMap = data['platforms']
    platformFile = open(DEPS + '/platforms.json', 'w')
    json.dump(platformMap, platformFile, indent=4)
    platformFile.close()

    toolchains = data['toolchains']
    toolchainsFile = open(DEPS + '/toolchains.json', 'w')
    json.dump(toolchains, toolchainsFile, indent=4)
    toolchainsFile.close()

    createManifest()
    downloadDep(firmware)
    downloadDep(compilers)
    downloadDep(tools)
    downloadDep(scripts)
    downloadDep(debuggers)

def uninstall():
    execpath = sys.argv[0]

    answer = input('Are you sure you want to uninstall neopo at ' + execpath + '? Type YES to continue (anything else to abort): ')

    if answer != 'YES':
        print('Aborted.')
        return

    os.remove(execpath)

    print('Uninstalled neopo.')
    print('Note: The .particle directory might still exist (remove it with `rm -rf ~/.particle`)')


# Create a Particle project and copy in Workbench settings
def create(path, name):
    tempEnv = os.environ.copy()
    tempEnv['PATH'] += ':' + DEPS

    subprocess.run(['particle', 'project', 'create',
                    path, '--name', name], env=tempEnv)
    pathlib.Path(path + '/' + name +
                 '/.vscode/').mkdir(parents=True, exist_ok=True)

    shutil.copyfile(DEPS + '/vscode/launch.json', path +
                    '/' + name + '/.vscode/launch.json')
    shutil.copyfile(DEPS + '/vscode/settings.json', path +
                    '/' + name + '/.vscode/settings.json')
    

    manifest = loadManifest()
    device = 'argon'
    configure(path + '/' + name, device, manifest['deviceOS'])


def getFirmwareData(data, version):
    for entry in data:
            if entry['version'] == version:
                return entry
    return False

def deviceToPlatformID(device):
    platformFile = open(DEPS + '/platforms.json', 'r')
    platforms = json.load(platformFile)
    platformFile.close()
    
    for platform in platforms:
        if platform['name'] == device:
            return platform['id']
    
    return False

def platformToDevice(platformID):
    platformFile = open(DEPS + '/platforms.json', 'r')
    platforms = json.load(platformFile)
    platformFile.close()

    for platform in platforms:
        if platform['id'] == platformID:
            return platform['name']
    
    return False

def getSupportedPlatforms(version):
    toolchainsFile = open(DEPS + '/toolchains.json', 'r')
    toolchains = json.load(toolchainsFile)
    toolchainsFile.close()

    for toolchain in toolchains:
        if toolchain['firmware'] == 'deviceOS@' + version:
            return toolchain['platforms']
    return False


def validateToolchain(platformID, version):
    return platformID in getSupportedPlatforms(version)

def checkFirmwareVersion(platform, version):
    firmwareFile = open(DEPS + '/firmware.json', 'r')
    data = json.load(firmwareFile)
    firmware = getFirmwareData(data, version)
    firmwareFile.close()

    platformID = deviceToPlatformID(platform)
    
    if not platformID:
        print('Invalid platform ' + platform + '!')
        return False

    if not firmware:
        print('Invalid deviceOS version ' + version + '!')
        return False

    if not validateToolchain(platformID, version):
        print('Platform ' + platform + ' is not supported in deviceOS version ' + version + '!')
        return False
    
    path = DEPS + '/deviceOS/' + version
    if os.path.isdir(path):
        # Version already installed
        return True
        
    downloadDep(firmware)


# Modify Workbench settings in a project (platform, firmwareVersion)
# TODO: Input verification, install specified firmware if required
def configure(projectPath, platform, firmwareVersion):
    
    if not checkFirmwareVersion(platform, firmwareVersion):
        exit(1)

    with open(projectPath + '/.vscode/settings.json', 'r+') as settings:
        data = json.loads(settings.read())
        data['particle.targetPlatform'] = platform
        data['particle.firmwareVersion'] = firmwareVersion
        settings.seek(0)
        json.dump(data, settings, indent=4)
        settings.truncate()
    print("Configured project " + projectPath + ':')
    print("\tparticle.targetPlatform: " + platform)
    print("\tparticle.firmwareVersion: " + firmwareVersion)

# Load Workbench settings from a project
def getSettings(projectPath):
    with open(projectPath + '/.vscode/settings.json', 'r+') as settings:
        return json.loads(settings.read())

# Print help information directly from Makefile
def build_help():
    manifest = loadManifest()
    compilerVersion = manifest['gcc-arm']
    scriptVersion = manifest['buildscripts']
    toolsVersion = manifest['buildtools']
    firmwareVersion = manifest['deviceOS']

    tempEnv = os.environ.copy()
    tempEnv['PATH'] += ':' + DEPS + '/gcc-arm/' + compilerVersion + '/bin'
    tempEnv['PATH'] += ':' + DEPS + '/buildtools/' + toolsVersion

    process = ['make', '-sf', DEPS + '/buildscripts/' + scriptVersion + '/Makefile',
               'PARTICLE_CLI_PATH=' + DEPS + '/particle', 'DEVICE_OS_PATH=' +
               DEPS + '/deviceOS/' + firmwareVersion, 'help'
               ]

    subprocess.run(process, env=tempEnv)

# Use the Makefile to build the specified target
def build(projectPath, command):
    manifest = loadManifest()
    compilerVersion = manifest['gcc-arm']
    scriptVersion = manifest['buildscripts']
    toolsVersion = manifest['buildtools']

    tempEnv = os.environ.copy()
    tempEnv['PATH'] += ':' + DEPS + '/gcc-arm/' + compilerVersion + '/bin'
    tempEnv['PATH'] += ':' + DEPS + '/buildtools/' + toolsVersion

    settings = getSettings(projectPath)
    platform = settings['particle.targetPlatform']
    firmwareVersion = settings['particle.firmwareVersion']
   
    deviceOSPath = DEPS + '/deviceOS/' + firmwareVersion
    legacy = '/firmware-' + firmwareVersion

    if os.path.isdir(deviceOSPath + legacy):
        deviceOSPath += legacy

    deviceOS = 'DEVICE_OS_PATH=' + deviceOSPath

    process = ['make', '-sf', DEPS + '/buildscripts/' + scriptVersion + '/Makefile',
               'PARTICLE_CLI_PATH=' + DEPS + '/particle', deviceOS,
               'PLATFORM=' + platform, 'APPDIR=' + projectPath, command
               ]

    #print(process)

    subprocess.run(process, env=tempEnv)

# Print help information about the program
def print_help():
    print("""Usage: neopo [OPTIONS] PROJECT

Options:
    General Options:
        help
        install
        uninstall
        versions
        create <project>

    Build Options:
        compile, build <project>
        flash <project>
        flash-all <project>
        clean <project>

    Special Options:
        run <target> <project>
        configure <platform> <version> <project>""")

# Parse the project path from the specified index and run a Makefile target
def buildCommand(command, index):
    try:
        project = os.environ['PWD'] + '/' + sys.argv[index]
    except IndexError:
        project = os.environ['PWD']

    try:
        build(project, command)
    except FileNotFoundError:
        print("Invalid project!")

# Print available versions and platforms
def versions():
    with open(DEPS + '/firmware.json', 'r') as firmwareFile:
        data = json.load(firmwareFile)
        print('Available deviceOS versions:')
        print()
        data.reverse()
        for entry in data:
            version = entry['version']
            platforms = getSupportedPlatforms(version)
            devices = []
            for platform in platforms:
                devices.append(platformToDevice(platform))
            
            devicesStr = devices[0]
            for device in devices[1:]:
                devicesStr += ', ' + device

            if len(version) < 8:
                version += '\t'
            
            print('  ' + version + '\t' +  '[ ' + devicesStr + ' ]')

        print()
        print('To configure a project use:') 
        print('\tneopo configure <platform> <version> <project>')


# Evaluate command-line arguments and call necessary functions
def main():
    # print(sys.argv)

    if len(sys.argv) == 1 or sys.argv[1] == 'help':
        print_help()
        return

    if sys.argv[1] == 'install':
        install()
        return

    if sys.argv[1] == 'uninstall':
        uninstall()
        return

    if sys.argv[1] == 'versions':
        versions()
        return

    if sys.argv[1] == 'create':
        try:
            projectPath = sys.argv[2]
        except IndexError:
            print("You must supply a path for the project!")
            return

        projectPath = os.path.abspath(projectPath)
        name = os.path.basename(projectPath)
        path = os.path.dirname(projectPath)
        create(path, name)
        return
    
    if sys.argv[1] == 'compile' or sys.argv[1] == 'build':
        buildCommand('compile-user', 2)
        return

    if sys.argv[1] == 'flash':
        buildCommand('flash-user', 2)
        return

    if sys.argv[1] == 'flash-all':
        buildCommand('flash-all', 2)
        return

    if sys.argv[1] == 'clean':
        buildCommand('clean-user', 2)
        return

    if sys.argv[1] == 'run':
        try:
            command = sys.argv[2]
        except IndexError:
            build_help()
            print("You must supply a Makefile target!")
            return

        buildCommand(command, 3)
        return

    if sys.argv[1] == 'configure' or sys.argv[1] == 'config':
        try:
            platform = sys.argv[2]
            version = sys.argv[3]
        except IndexError:
            print("You must supply platform and deviceOS version!")
            return
        
        try:
            projectPath = sys.argv[4]
        except IndexError:
            projectPath = os.environ['PWD']
        
        configure(projectPath, platform, version)
        return

    print("Invalid command!")
    print_help()


if __name__ == "__main__":
    main()
